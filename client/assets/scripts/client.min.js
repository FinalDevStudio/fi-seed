!function() {
    "use strict";
    angular.module("App", [ "ngRoute", "angularFileUpload", "luegg.directives", "Adapter", "Session", "Moment", "Auth" ]);
}(), function() {
    "use strict";
    angular.module("App").filter("bytes", function() {
        return function(bytes, precision) {
            if (isNaN(parseFloat(bytes)) || !isFinite(bytes)) return "-";
            precision || (precision = 1);
            var units = [ "bytes", "kB", "MB", "GB", "TB", "PB" ], number = Math.floor(Math.log(bytes) / Math.log(1024)), size = bytes / Math.pow(1024, Math.floor(number));
            return size.toFixed(precision) + " " + units[number];
        };
    });
}(), function() {
    "use strict";
    angular.module("App").filter("icon", function() {
        return function(body) {
            return "string" == typeof body ? "comment" : "clipboard";
        };
    });
}(), function() {
    "use strict";
    angular.module("App").filter("fromNow", function($moment) {
        return $moment.locale("es"), function(date) {
            return $moment(date).fromNow();
        };
    }).filter("calendar", function($moment) {
        return $moment.locale("es"), function(date) {
            return $moment(date).calendar();
        };
    });
}(), function() {
    "use strict";
    angular.module("Adapter", []).factory("$adapter", function() {
        return {
            adapted: !1,
            adaptIfNeeded: function() {
                this.adapted || this.adapt();
            },
            adapt: function() {
                function maybeFixConfiguration(pcConfig) {
                    if (pcConfig) for (var i = 0; i < pcConfig.iceServers.length; i++) pcConfig.iceServers[i].hasOwnProperty("urls") && (pcConfig.iceServers[i].url = pcConfig.iceServers[i].urls, 
                    delete pcConfig.iceServers[i].urls);
                }
                console.log("Adapting WebRTC...");
                var RTCPeerConnection = null, getUserMedia = null, attachMediaStream = null, reattachMediaStream = null, webrtcDetectedBrowser = null, webrtcDetectedVersion = null;
                if (navigator.mozGetUserMedia) console.log("This appears to be Firefox"), webrtcDetectedBrowser = "firefox", 
                webrtcDetectedVersion = parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10), 
                RTCPeerConnection = function(pcConfig, pcConstraints) {
                    return maybeFixConfiguration(pcConfig), new mozRTCPeerConnection(pcConfig, pcConstraints);
                }, window.RTCSessionDescription = mozRTCSessionDescription, window.RTCIceCandidate = mozRTCIceCandidate, 
                getUserMedia = navigator.mozGetUserMedia.bind(navigator), navigator.getUserMedia = getUserMedia, 
                window.createIceServer = function(url, username, password) {
                    var iceServer = null, urlParts = url.split(":");
                    if (0 === urlParts[0].indexOf("stun")) iceServer = {
                        url: url
                    }; else if (0 === urlParts[0].indexOf("turn")) if (27 > webrtcDetectedVersion) {
                        var turnUrlParts = url.split("?");
                        (1 === turnUrlParts.length || 0 === turnUrlParts[1].indexOf("transport=udp")) && (iceServer = {
                            url: turnUrlParts[0],
                            credential: password,
                            username: username
                        });
                    } else iceServer = {
                        url: url,
                        credential: password,
                        username: username
                    };
                    return iceServer;
                }, window.createIceServers = function(urls, username, password) {
                    for (var iceServers = [], i = 0; i < urls.length; i++) {
                        var iceServer = window.createIceServer(urls[i], username, password);
                        null !== iceServer && iceServers.push(iceServer);
                    }
                    return iceServers;
                }, attachMediaStream = function(element, stream) {
                    console.log("Attaching media stream"), element.mozSrcObject = stream;
                }, reattachMediaStream = function(to, from) {
                    console.log("Reattaching media stream"), to.mozSrcObject = from.mozSrcObject;
                }; else if (navigator.webkitGetUserMedia) {
                    console.log("This appears to be Chrome"), webrtcDetectedBrowser = "chrome";
                    var result = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
                    webrtcDetectedVersion = null !== result ? parseInt(result[2], 10) : 999, window.createIceServer = function(url, username, password) {
                        var iceServer = null, urlParts = url.split(":");
                        return 0 === urlParts[0].indexOf("stun") ? iceServer = {
                            url: url
                        } : 0 === urlParts[0].indexOf("turn") && (iceServer = {
                            url: url,
                            credential: password,
                            username: username
                        }), iceServer;
                    }, window.createIceServers = function(urls, username, password) {
                        var iceServers = [];
                        if (webrtcDetectedVersion >= 34) iceServers = {
                            urls: urls,
                            credential: password,
                            username: username
                        }; else for (var i = 0; i < urls.length; i++) {
                            var iceServer = window.createIceServer(urls[i], username, password);
                            null !== iceServer && iceServers.push(iceServer);
                        }
                        return iceServers;
                    }, RTCPeerConnection = function(pcConfig, pcConstraints) {
                        return 34 > webrtcDetectedVersion && maybeFixConfiguration(pcConfig), new webkitRTCPeerConnection(pcConfig, pcConstraints);
                    }, getUserMedia = navigator.webkitGetUserMedia.bind(navigator), navigator.getUserMedia = getUserMedia, 
                    attachMediaStream = function(element, stream) {
                        "undefined" != typeof element.srcObject ? element.srcObject = stream : "undefined" != typeof element.mozSrcObject ? element.mozSrcObject = stream : "undefined" != typeof element.src ? element.src = URL.createObjectURL(stream) : console.log("Error attaching stream to element");
                    }, reattachMediaStream = function(to, from) {
                        to.src = from.src;
                    };
                } else console.log("Browser does not appear to be WebRTC-capable");
                window.RTCPeerConnection = RTCPeerConnection, window.getUserMedia = getUserMedia, 
                window.attachMediaStream = attachMediaStream, window.reattachMediaStream = reattachMediaStream, 
                window.webrtcDetectedBrowser = webrtcDetectedBrowser, window.webrtcDetectedVersion = webrtcDetectedVersion, 
                this.adapted = !0;
            }
        };
    });
}(), function() {
    "use strict";
    var auth = angular.module("Auth", []);
    auth.run(function($rootScope) {
        $rootScope.$on("$routeChangeStart", function() {});
    });
}(), function() {
    "use strict";
    angular.module("App").factory("$mimeicon", function() {
        return {
            "for": function(type) {
                var idx, len, types = [ {
                    regexp: /^application\/.*?(?:zip|compressed).*?$/gi,
                    icon: "zip-o"
                }, {
                    regexp: /^image\/.+$/gi,
                    icon: "image-o"
                }, {
                    regexp: /^(?:(?:application\/(?:(?:vnd\.)?.*?(?:officedocument\.wordprocessingml|opendocument\.text|ms-?word).*?))|text\/plain)$/gi,
                    icon: "text-o"
                }, {
                    regexp: /^(?:application\/vnd\.(?:.*?(?:(?:officedocument|opendocument)\.spreadsheet|ms-excel).*?))$/gi,
                    icon: "excel-o"
                }, {
                    regexp: /^application\/pdf$/gi,
                    icon: "pdf-o"
                } ];
                for (len = types.length, idx = 0; len > idx; idx += 1) if (types[idx].regexp.test(type)) return types[idx].icon;
                return "o";
            }
        };
    });
}(), function() {
    "use strict";
    angular.module("Moment", []).factory("$moment", function() {
        return moment;
    });
}(), function() {
    "use strict";
    var session = angular.module("Session", []);
    session.factory("$session", function($rootScope) {
        return $rootScope.session = {}, {
            login: function(user) {
                $rootScope.session.user = user;
            },
            logout: function() {
                $rootScope.session = {};
            },
            flash: function(message) {
                message ? $rootScope.session.flash = message : delete $rootScope.session.flash;
            },
            get: function(key) {
                return $rootScope.session[key];
            },
            set: function(key, value) {
                $rootScope.session[key] = value;
            },
            "delete": function(key) {
                delete $rootScope.session[key];
            }
        };
    }), session.run(function($rootScope, $session) {
        $rootScope.$on("$routeChangeStart", function() {
            $session.delete("flash");
        });
    });
}(), function() {
    "use strict";
    angular.module("App").factory("$conference", function($rootScope, $adapter, $io, $routeParams) {
        function openSignaling() {
            signal = $io.connect(namespace, {
                multiplex: !1
            }), signal.on("created", function() {
                console.log("You have created this room");
            }), signal.on("joined", function() {
                console.log("You have joined this room"), createOffer();
            }), signal.on("offer", function(offer) {
                console.log("A peer has sent you an offer"), createAnswer(offer);
            }), signal.on("answer", function(answer) {
                console.log("A peer has answered your offer"), peerconn.setRemoteDescription(new RTCSessionDescription(answer));
            }), signal.on("ice candidate", function(candidate) {
                console.log("A peer has sent you an ICE candidate"), peerconn.addIceCandidate(new RTCIceCandidate(candidate));
            }), signal.on("leave", function() {
                peerconn && (peerconn.close(), peerconn = null), document.getElementById("remote-video").innerHTML = null;
            });
        }
        function addVideo(local, stream) {
            var video = document.createElement("video");
            document.getElementById(local ? "local-video" : "remote-video").appendChild(video), 
            video.setAttribute("autoplay", "autoplay"), local && video.setAttribute("muted", "muted"), 
            attachMediaStream(video, stream);
        }
        function joinRoom() {
            signal.emit("join", $routeParams.sic);
        }
        function createPeerConnection() {
            var pc = new RTCPeerConnection(configuration, options);
            return pc.addStream(localStream), pc.onicecandidate = function(event) {
                event.candidate && (console.log("Got ICE candidate"), signal.emit("ice candidate", event.candidate));
            }, pc.onaddstream = function(event) {
                console.log("Adding remote stream"), addVideo(!1, event.stream);
            }, pc;
        }
        function createOffer() {
            peerconn = createPeerConnection(), peerconn.createOffer(function(offer) {
                peerconn.setLocalDescription(offer), signal.emit("offer", offer);
            }, function(err) {
                console.error(err);
            }, constraints);
        }
        function createAnswer(offer) {
            peerconn = createPeerConnection(), peerconn.setRemoteDescription(new RTCSessionDescription(offer)), 
            peerconn.createAnswer(function(answer) {
                peerconn.setLocalDescription(answer), signal.emit("answer", answer);
            }, function(err) {
                console.error(err);
            }, constraints);
        }
        function leave() {
            peerconn && (peerconn.close(), peerconn = null), document.getElementById("local-video").innerHTML = null, 
            localStream.stop(), signal.emit("leave");
        }
        var signal, peerconn, localStream, namespace = "/room/conference", configuration = {
            iceServers: [ {
                url: "stun:stun1.l.google.com:19302"
            }, {
                url: "stun:stun2.l.google.com:19302"
            }, {
                url: "stun:stun3.l.google.com:19302"
            }, {
                url: "stun:stun4.l.google.com:19302"
            }, {
                url: "stun:stun.l.google.com:19302"
            }, {
                url: "stun:stun01.sipphone.com"
            }, {
                url: "stun:stun.voiparound.com"
            }, {
                url: "stun:stun.voipbuster.com"
            }, {
                url: "stun:stun.rixtelecom.se"
            }, {
                url: "stun:stun.voipstunt.com"
            }, {
                url: "stun:stun.voxgratia.org"
            }, {
                url: "stun:stun.softjoys.com"
            }, {
                url: "stun:stun.ideasip.com"
            }, {
                url: "stun:stun.fwdnet.net"
            }, {
                url: "stun:stun.schlund.de"
            }, {
                url: "stun:stun.ekiga.net"
            }, {
                url: "stun:stunserver.org"
            }, {
                url: "stun:stun.iptel.org"
            }, {
                url: "stun:stun.xten.com"
            }, {
                url: "turn:numb.viagenie.ca",
                username: "webrtc@live.com",
                credential: "muazkh"
            }, {
                url: "turn:192.158.29.39:3478?transport=udp",
                credential: "JZEOEt2V3Qb0y27GRntt2u2PAYA=",
                username: "28224511:1379330808"
            }, {
                url: "turn:192.158.29.39:3478?transport=tcp",
                credential: "JZEOEt2V3Qb0y27GRntt2u2PAYA=",
                username: "28224511:1379330808"
            } ]
        }, options = {
            optional: [ {
                DtlsSrtpKeyAgreement: !0
            } ]
        }, constraints = {
            mandatory: {
                OfferToReceiveAudio: !0,
                OfferToReceiveVideo: !0
            }
        }, mediaOptions = {
            video: !0,
            audio: !0
        };
        return $rootScope.$on("$locationChangeStart", function() {
            leave();
        }), openSignaling(), {
            active: !1,
            start: function() {
                this.active = !0, $adapter.adaptIfNeeded(), getUserMedia(mediaOptions, function(stream) {
                    localStream = stream, addVideo(!0, localStream), joinRoom();
                }, function(err) {
                    console.error(err);
                });
            },
            stop: function() {
                this.active = !1, document.getElementById("local-video").innerHTML = null, document.getElementById("remote-video").innerHTML = null, 
                leave();
            }
        };
    });
}(), function() {
    "use strict";
    angular.module("App").factory("$io", function() {
        return {
            connect: function(namespace, options) {
                return window.io(namespace, options);
            }
        };
    });
}(), function() {
    "use strict";
    angular.module("App").factory("$statics", function($http, $q) {
        return {
            get: function(param) {
                var deferred = $q.defer(), name = "", query = {};
                if (!param) throw new TypeError("Parameter cannot be null!");
                if (!angular.isArray(param) && !angular.isString(param)) throw new TypeError("Wrong parameter type! Must be a String or an Array.");
                return query.params = {
                    statics: param
                }, $http.get("/api/statics" + name, query).success(function(data) {
                    deferred.resolve(data);
                }).error(function(data, status) {
                    deferred.reject(data, status);
                }), deferred.promise;
            }
        };
    });
}(), function() {
    "use strict";
    angular.module("App").controller("Navbar", function($scope, $location, $http, $session) {
        $scope.logout = function() {
            $http.get("/api/logout").success(function() {
                $session.logout(), $location.path("/");
            }).error(function() {});
        };
    });
}(), function() {
    "use strict";
    angular.module("App").controller("Pages:Help", function($scope, $window) {
        $scope.back = function() {
            $window.history.back();
        };
    });
}(), function() {
    "use strict";
    angular.module("App").controller("Pages:Home", function() {});
}(), function() {
    "use strict";
    angular.module("App").controller("Pages:Login", function($scope, $http, $location, $session) {
        $scope.error = !1, $scope.submitting = !1, $scope.login = function() {
            $scope.submitting = !0, $scope.error = !1, $http.post("/api/login", {
                email: $scope.form.email,
                password: $scope.form.password
            }).success(function(user) {
                $session.login(user), $location.path("/welcome");
            }).error(function() {
                $scope.error = !0;
            }).finally(function() {
                $scope.submitting = !1;
            });
        };
    });
}(), function() {
    "use strict";
    angular.module("App").controller("Pages:Profile", function($scope, $http, $location, $session) {
        $scope.workplaces = [], $http.get("/api/workplaces/own").success(function(data) {
            $scope.workplaces = data;
        }), $scope.addWorkplace = function() {
            $http.post("/api/workplaces", {
                name: $scope.addWorkplaceForm.name
            }).success(function(data) {
                $scope.workplaces.push(data), $scope.addWorkplaceForm.name = null;
            });
        }, $scope.setWorkplace = function(workplace) {
            $session.set("workplace", workplace);
        };
    });
}(), function() {
    "use strict";
    angular.module("App").controller("Pages:Recover", function($scope, $http) {
        $scope.pageClass = "users-recover", $scope.recoverError = !1, $scope.submitting = !1, 
        $scope.submit = function() {
            $http.post("/api/recover", {
                _csrf: $scope.recoverForm.csrf,
                email: $scope.recoverForm.email
            }).success(function() {}).error(function() {});
        };
    });
}(), function() {
    "use strict";
    angular.module("App").controller("Pages:Signup", function($scope, $http, $location, $session) {
        $scope.pageClass = "pages-signup", $scope.submitting = !1, $scope.submit = function() {
            $scope.submitting = !0, $http.post("/api/users", {
                name: $scope.form.name,
                email: $scope.form.email,
                password: $scope.form.password
            }).success(function(user) {
                $session.login(user), $location.path("/welcome");
            }).error(function(data, status) {}).finally(function() {
                $scope.submitting = !1;
            });
        };
    });
}(), function() {
    "use strict";
    angular.module("App").controller("Pages:Welcome", function($scope, $http, $location, $session) {
        $scope.workplaces = [], $scope.adding = !1, $scope.setting = !1, $http.get("/api/workplaces/own").success(function(data) {
            $scope.workplaces = data;
        }), $scope.addWorkplace = function() {
            $scope.adding = !0, $http.post("/api/workplaces", {
                name: $scope.addWorkplaceForm.name
            }).success(function(data) {
                $scope.addWorkplaceForm.name = null, $scope.workplaces.push(data);
            }).finally(function() {
                $scope.adding = !1;
            });
        }, $scope.setWorkplace = function(workplace) {
            $scope.setting = !0, $session.set("workplace", workplace), $http.post("/api/workplaces/set/" + workplace._id).success(function() {
                $location.path("/worktable/ongoing");
            }).finally(function() {
                $scope.setting = !1;
            });
        };
    });
}(), function() {
    "use strict";
    angular.module("App").controller("Sidebar", function($scope, $location) {
        $scope.$on("$routeChangeStart", function() {
            $scope.location = $location.path();
        });
    });
}(), function() {
    "use strict";
    angular.module("App").config(function($routeProvider) {
        $routeProvider.when("/", {
            controller: "Pages:Home",
            templateUrl: "/templates/pages/home.html"
        }).when("/help", {
            controller: "Pages:Help",
            templateUrl: "/templates/pages/help.html"
        }).when("/login", {
            controller: "Pages:Login",
            templateUrl: "/templates/pages/login.html"
        }).when("/recover", {
            controller: "Pages:Recover",
            templateUrl: "/templates/pages/recover.html"
        }).when("/signup", {
            controller: "Pages:Signup",
            templateUrl: "/templates/pages/signup.html"
        }).when("/profile", {
            controller: "Pages:Profile",
            templateUrl: "/templates/pages/profile.html"
        }).when("/welcome", {
            controller: "Pages:Welcome",
            templateUrl: "/templates/pages/welcome.html"
        });
    });
}(), function() {
    "use strict";
    angular.module("App").config(function($routeProvider, $locationProvider) {
        $routeProvider.otherwise({
            redirectTo: "/notfound"
        }).when("/notfound", {
            templateUrl: "/templates/notfound.html"
        }), $locationProvider.html5Mode(!0);
    }).run(function($rootScope, $location, $session, $http) {
        $http.get("/api/session").success(function(data) {
            $session.login(data.user), $session.set("workplace", data.workplace), "/" === $location.path() && $location.path("/worktable/ongoing");
        });
    });
}();